import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;
import static java.util.stream.Collectors.joining;


/*
    There are N clusters. Each cluster contains of xi servers.
    A time window [ai, ai+xi] was allocated for each cluster to update servers.
    These windows may overlap.
    Two clusters cannot be updated at the same time.

    Select optimal clusters for update to maximize the number of updated servers.

    Input format:
        [number of clusters]
        [a0] [x0]
        [a1] [x1]
        ...

    Output format:
        [number of updated servers]
        [cluster i] [cluster j] [cluster k] ...

    input:
        4
        1 4
        4 11
        8 5
        12 5

    output:
        11
        1

    input:
        4
        1 4
        4 11
        8 3
        12 5

    output:
        12
        3 2 0
*/
public class CriticalVulnerability {

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = "";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }

    static class Interval implements Comparable<Interval> {
        int id;
        long start;
        long end;
        long duration;

        Interval(int id, long start, long end) {
            this.id = id;
            this.start = start;
            this.end = end;
            this.duration = end - start;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Interval interval = (Interval) o;
            return start == interval.start &&
                    end == interval.end &&
                    duration == interval.duration;
        }

        @Override
        public int hashCode() {
            return Objects.hash(start, end, duration);
        }

        @Override
        public int compareTo(Interval o) {
            if (this.end < o.end) {
                return -1;
            } else if (this.end > o.end) {
                return 1;
            }

            if (this.start < o.start) {
                return -1;
            } else if (this.start > o.start) {
                return 1;
            }

            if (this.id < o.id) {
                return -1;
            } else if (this.id > o.id) {
                return 1;
            }

            return 0;
        }
    }

    /*
    Find the last cluster (interval) with end <= endTime
          (5)
        3
        5
        5 <-- return [2]
        7
        9
    [-1] if no clusters with end <= endTime
    */
    private static int binarySearchLastCluster(Interval[] clusters, long endTime) {
        int after = 0, beforeOrEq = clusters.length - 1;

        while (after <= beforeOrEq) {
            int mid = after + (beforeOrEq - after) / 2;

            if (clusters[mid].end <= endTime) {
                after = mid + 1;
            } else {
                beforeOrEq = mid - 1;
            }
        }

        return after - 1;
    }

    public static void main(String[] args) {
        FastReader reader = new FastReader();
        PrintWriter out = new PrintWriter(System.out);

        int N = reader.nextInt();

        Interval[] intervals = new Interval[N];

        for (int i = 0; i < N; i++) {
            long ai = reader.nextLong();
            long xi = reader.nextLong();
            intervals[i] = new Interval(i, ai, ai + xi);
        }

        long maxUpdatedServers;
        Set<Integer> updatedClusters = new HashSet<>();


        Arrays.sort(intervals);

        long[] dp = new long[N + 1];
        dp[0] = 0;

        int[] clusters = new int[N + 1];
        boolean[] notInclude = new boolean[N + 1];
        clusters[0] = -1;

        for (int i = 0; i < N; i++) {
            long maxWithoutThisCluster = dp[i];
            long maxWithThisCluster;

            int lastClusterBeforeThis = binarySearchLastCluster(intervals, intervals[i].start);

            maxWithThisCluster = dp[lastClusterBeforeThis + 1] + intervals[i].duration;

            if (maxWithThisCluster > maxWithoutThisCluster) {
                dp[i+1] = maxWithThisCluster;
                if (lastClusterBeforeThis >= 0 && notInclude[lastClusterBeforeThis]) {
                    clusters[i] = clusters[lastClusterBeforeThis];
                } else {
                    clusters[i] = lastClusterBeforeThis;
                }
                clusters[i+1] = i;
            } else {
                dp[i+1] = maxWithoutThisCluster;
                clusters[i+1] = clusters[i];
                notInclude[i] = true;
            }
        }

        maxUpdatedServers = dp[N];

        for (int nxtCluster = clusters[N]; nxtCluster >= 0; nxtCluster = clusters[nxtCluster]) {
            updatedClusters.add(intervals[nxtCluster].id);
        }

        out.println(maxUpdatedServers);

        out.println(updatedClusters.stream().map(String::valueOf).collect(joining(" ")));

        out.flush();
    }
}